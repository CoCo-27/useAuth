{"version":3,"file":"index.js","sources":["../src/authReducer.ts","../src/useAuth.ts","../src/providers/Auth0.ts","../src/providers/NetlifyIdentity.ts","../src/AuthConfig.tsx","../src/AuthProvider.tsx"],"sourcesContent":["import { addSeconds, differenceInSeconds, isAfter } from \"date-fns\";\nimport { Machine, assign, interpret } from \"xstate\";\nimport { choose } from \"xstate/lib/actions\";\nimport { AuthState } from \"./types\";\n\nexport const authMachine = Machine<AuthState>(\n    {\n        id: \"useAuth\",\n        initial: \"unauthenticated\",\n        context: {\n            user: {},\n            expiresAt: null,\n            authResult: null,\n            isAuthenticating: false,\n            error: undefined,\n            errorType: undefined,\n            config: {\n                navigate: () =>\n                    console.error(\n                        \"Please specify a navigation method that works with your router\"\n                    ),\n                // TODO: detect default\n                callbackDomain: \"http://localhost:8000\"\n            }\n        },\n        states: {\n            unauthenticated: {\n                on: {\n                    LOGIN: \"authenticating\",\n                    CHECK_SESSION: \"verifying\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                }\n            },\n            authenticating: {\n                on: {\n                    ERROR: \"error\",\n                    AUTHENTICATED: \"authenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            verifying: {\n                invoke: {\n                    id: \"checkSession\",\n                    src: (context, event) =>\n                        context.config.authProvider!.checkSession(),\n                    onDone: {\n                        target: \"authenticated\"\n                    },\n                    onError: {\n                        target: \"error\"\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            authenticated: {\n                on: {\n                    LOGOUT: \"unauthenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    },\n                    CHECK_SESSION: \"verifying\"\n                },\n                entry: [\"saveUserToContext\", \"saveToLocalStorage\"],\n                exit: choose([\n                    {\n                        cond: (context, event) =>\n                            event.type !== \"CHECK_SESSION\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                ])\n            },\n            error: {\n                entry: [\n                    \"saveErrorToContext\",\n                    \"clearUserFromContext\",\n                    \"clearLocalStorage\"\n                ]\n            }\n        }\n    },\n    {\n        actions: {\n            startAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: true\n                };\n            }),\n            stopAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: false\n                };\n            }),\n            saveUserToContext: assign((context, event) => {\n                const { authResult, user } = event.data ? event.data : event;\n                const expiresAt = addSeconds(new Date(), authResult.expiresIn);\n\n                return {\n                    user,\n                    authResult,\n                    expiresAt\n                };\n            }),\n            clearUserFromContext: assign(context => {\n                return {\n                    user: {},\n                    expiresAt: null,\n                    authResult: null\n                };\n            }),\n            saveToLocalStorage: (context, event) => {\n                const { expiresAt, user } = context;\n\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(\n                        \"useAuth:expires_at\",\n                        expiresAt ? expiresAt.toISOString() : \"0\"\n                    );\n                    localStorage.setItem(\"useAuth:user\", JSON.stringify(user));\n                }\n            },\n            clearLocalStorage: () => {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.removeItem(\"useAuth:expires_at\");\n                    localStorage.removeItem(\"useAuth:user\");\n                }\n            },\n            saveErrorToContext: assign((context, event) => {\n                return {\n                    errorType: event.errorType,\n                    error: event.error\n                };\n            }),\n            setConfig: assign((context, event) => {\n                return {\n                    config: {\n                        ...context.config,\n                        ...event\n                    }\n                };\n            })\n        }\n    }\n);\n\n// check localstorage and login as soon as this file loads\nfunction hydrateFromLocalStorage(send: any) {\n    if (typeof localStorage !== \"undefined\") {\n        const expiresAt = new Date(\n                localStorage.getItem(\"useAuth:expires_at\") || \"0\"\n            ),\n            now = new Date();\n\n        if (isAfter(expiresAt, now)) {\n            const user = JSON.parse(\n                localStorage.getItem(\"useAuth:user\") || \"{}\"\n            );\n            send(\"LOGIN\");\n            send(\"AUTHENTICATED\", {\n                user,\n                authResult: {\n                    expiresIn: differenceInSeconds(expiresAt, now)\n                }\n            });\n        }\n    }\n}\n\nexport const authService = interpret(authMachine);\nauthService.start();\n\nhydrateFromLocalStorage(authService.send);\n","import { useCallback } from \"react\";\n\nimport { useAuthInterface } from \"./types\";\nimport { useService } from \"@xstate/react\";\nimport { authService } from \"./authReducer\";\nimport { isAfter } from \"date-fns\";\n\n/**\n * The main API for useAuth\n *\n * @return {boolean} isAuthenticated is current user authenticated\n * @return {boolean} isAuthenticating currently running authentication\n * @return {function} isAuthorized check if current user is authenticated and matches list of roles\n * @return {object} user current user\n * @return {string} userId current user's identifier\n * @return {object} authResult raw authentication result object from auth provider\n * @return {function} login start the login process\n * @return {function} signup same as login, passes { mode: \"signUp\", screen_hint: \"signup\" } to Auth0\n * @return {function} logout start the logout process\n * @return {function} handleAuthentication function to call on your callback page\n */\nexport const useAuth: useAuthInterface = () => {\n    const [state, dispatch] = useService(authService);\n\n    const { authProvider, navigate, callbackDomain } = state.context.config;\n\n    const login = () => {\n        authProvider?.authorize();\n    };\n\n    const signup = () => {\n        authProvider?.signup();\n    };\n\n    const logout = (postLogoutRoute?: string) => {\n        if (postLogoutRoute) {\n            authProvider?.logout(`${callbackDomain}${postLogoutRoute}`);\n        } else {\n            authProvider?.logout();\n        }\n\n        dispatch(\"LOGOUT\");\n\n        // Return to the homepage after logout.\n        navigate(postLogoutRoute || \"/\");\n    };\n\n    const handleAuthentication = useCallback(\n        async ({ postLoginRoute = \"/\" } = {}) => {\n            if (!authProvider || !navigate) {\n                console.warn(\"authProvider not configured yet\");\n                return;\n            }\n\n            if (typeof window !== \"undefined\") {\n                dispatch(\"LOGIN\");\n\n                const loggedIn = await authProvider.handleLoginCallback(\n                    dispatch\n                );\n\n                if (loggedIn) {\n                    navigate(postLoginRoute);\n                }\n            }\n        },\n        [authProvider, navigate]\n    );\n\n    const isAuthenticated = () => {\n        return !!(\n            state.context.expiresAt &&\n            isAfter(state.context.expiresAt, new Date())\n        );\n    };\n\n    const isAuthorized = (roles: string | string[]) => {\n        const _roles = Array.isArray(roles) ? roles : [roles];\n        const userRoles = authProvider?.userRoles(state.context.user);\n\n        if (!isAuthenticated() || !userRoles) {\n            return false;\n        } else {\n            return _roles.some(role => userRoles.includes(role));\n        }\n    };\n\n    return {\n        isAuthenticating: state.context.isAuthenticating,\n        isAuthenticated,\n        isAuthorized,\n        user: state.context.user,\n        userId: authProvider?.userId(state.context.user),\n        authResult: state.context.authResult,\n        login,\n        signup,\n        logout,\n        handleAuthentication,\n        dispatch\n    };\n};\n","import Auth0Client, {\n    Auth0DecodedHash,\n    Auth0Error,\n    Auth0ParseHashError,\n    Auth0UserProfile,\n    AuthOptions as Auth0Options\n} from \"auth0-js\";\nimport {\n    AuthOptions,\n    AuthProviderClass,\n    AuthUser,\n    ProviderOptions\n} from \"../types\";\n\n// Wrapper that provides a common interface for different providers\n// Modeled after Auth0 because that was first :)\nexport class Auth0 implements AuthProviderClass {\n    private auth0: Auth0Client.WebAuth;\n    private dispatch: (eventName: string, eventData?: any) => void;\n    private customPropertyNamespace?: string;\n\n    public checkSessionOnLoad = true;\n\n    constructor(params: AuthOptions) {\n        this.dispatch = params.dispatch;\n        this.customPropertyNamespace = params.customPropertyNamespace;\n        this.auth0 = new Auth0Client.WebAuth({\n            ...(params as Auth0Options)\n        });\n    }\n\n    // Makes configuration easier by guessing default options\n    static addDefaultParams(params: ProviderOptions, callbackDomain: string) {\n        const vals = params as Auth0Options;\n\n        return {\n            redirectUri: `${callbackDomain}/auth0_callback`,\n            audience: `https://${vals.domain}/api/v2/`,\n            responseType: \"token id_token\",\n            scope: \"openid profile email\",\n            ...vals\n        };\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.auth0.authorize();\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.auth0.authorize({\n            mode: \"signUp\",\n            screen_hint: \"signup\"\n        });\n    }\n\n    // Logs user out on the underlying service\n    public logout(returnTo?: string) {\n        this.auth0.logout({ returnTo });\n    }\n\n    // Returns the userId from Auth0 shape of data\n    public userId(user: Auth0UserProfile): string {\n        return user.sub;\n    }\n\n    // Returns user roles from Auth0 shape of data\n    public userRoles(user: AuthUser): string[] | null {\n        const metadata =\n            user[\n                // make this friendlier to use if you leave a trailing slash in config\n                `${this.customPropertyNamespace}/user_metadata`.replace(\n                    /\\/+user_metadata/,\n                    \"/user_metadata\"\n                )\n            ];\n\n        return metadata?.roles || null;\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            this.auth0.parseHash(\n                async (\n                    err: Auth0ParseHashError | null,\n                    authResult: Auth0DecodedHash | null\n                ) => {\n                    if (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"authResult\"\n                        });\n                        resolve(false);\n                    }\n\n                    try {\n                        const loggedIn = await this.handleAuthResult(\n                            authResult\n                        );\n\n                        resolve(loggedIn);\n                    } catch (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"handleAuth\"\n                        });\n                        resolve(false);\n                    }\n                }\n            );\n        });\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: Auth0UserProfile;\n        authResult: Auth0DecodedHash;\n    }> {\n        return new Promise((resolve, reject) => {\n            this.auth0.checkSession(\n                {},\n                async (err: any, authResult: Auth0DecodedHash) => {\n                    if (\n                        !err &&\n                        authResult &&\n                        authResult.accessToken &&\n                        authResult.idToken\n                    ) {\n                        // fetch user data\n                        try {\n                            const user = await this.fetchUser(authResult);\n\n                            resolve({\n                                user,\n                                authResult\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(err || new Error(\"Session invalid\"));\n                    }\n                }\n            );\n        });\n    }\n\n    // Parses auth result and dispatches the AUTHENTICATED event\n    private async handleAuthResult(authResult: Auth0DecodedHash | null) {\n        if (authResult && authResult.accessToken && authResult.idToken) {\n            const user = await this.fetchUser(authResult);\n\n            this.dispatch(\"AUTHENTICATED\", {\n                authResult,\n                user\n            });\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Fetches current user info\n    private async fetchUser(\n        authResult: Auth0DecodedHash | null\n    ): Promise<Auth0UserProfile> {\n        return new Promise((resolve, reject) => {\n            this.auth0.client.userInfo(\n                authResult?.accessToken || \"\",\n                (err: Auth0Error | null, user: Auth0UserProfile) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(user);\n                    }\n                }\n            );\n        });\n    }\n}\n","import {\n    AuthOptions,\n    AuthProviderClass,\n    AuthUser,\n    ProviderOptions\n} from \"../types\";\nimport NetlifyIdentityWidget, { User } from \"netlify-identity-widget\";\n\n// Wrapper for NetlifyIdentity conforming to auth provider interface\nexport class NetlifyIdentity implements AuthProviderClass {\n    private netlifyIdentity: any;\n    private dispatch: (eventName: string, eventData?: any) => void;\n\n    public checkSessionOnLoad = false;\n\n    constructor(params: AuthOptions) {\n        this.netlifyIdentity = NetlifyIdentityWidget;\n\n        this.netlifyIdentity.init(params as NetlifyIdentityWidget.InitOptions);\n        this.dispatch = params.dispatch;\n\n        this.netlifyIdentity.on(\"error\", (error: Error) => {\n            this.dispatch(\"ERROR\", {\n                error,\n                errorType: \"netlifyError\"\n            });\n        });\n        this.netlifyIdentity.on(\"login\", (user: User) => {\n            this.dispatch(\"AUTHENTICATED\", {\n                user,\n                authResult: {\n                    expiresIn: user.token?.expires_in\n                }\n            });\n        });\n        this.netlifyIdentity.on(\"init\", (user: User) => {\n            if (user) {\n                this.dispatch(\"LOGIN\");\n                this.dispatch(\"AUTHENTICATED\", {\n                    user,\n                    authResult: {\n                        expiresIn: user.token?.expires_in\n                    }\n                });\n            }\n        });\n    }\n\n    static addDefaultParams(params: ProviderOptions, callbackDomain: string) {\n        const vals = params as NetlifyIdentityWidget.InitOptions;\n        return vals;\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.dispatch(\"LOGIN\");\n        this.netlifyIdentity.open(\"login\");\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.dispatch(\"LOGIN\");\n        this.netlifyIdentity.open(\"signup\");\n    }\n\n    // Logs user out on the underlying service\n    public logout(returnTo?: string) {\n        this.netlifyIdentity.logout();\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(dispatch: any): Promise<boolean> {\n        console.warn(\n            \"handleLoginCallback is unnecessary with Netlify Identity Widget\"\n        );\n        return true;\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: any;\n        authResult: any;\n    }> {\n        console.warn(\n            \"checkSession is unnecessary with Netlify Identity Widget\"\n        );\n        return {\n            user: {},\n            authResult: {}\n        };\n    }\n\n    // Returns the userId from NetlifyIdentity shape of data\n    public userId(user: NetlifyIdentityWidget.User): string {\n        return user.id;\n    }\n\n    // Returns user roles from NetlifyIdentity shape of data\n    public userRoles(user: NetlifyIdentityWidget.User): string[] | null {\n        return [user.role] || null;\n    }\n}\n","import * as React from \"react\";\nimport { AuthConfigInterface, ProviderOptions } from \"./types\";\nimport { useAuth } from \"./useAuth\";\n\nexport const AuthConfig: AuthConfigInterface = ({\n    authProvider,\n    params,\n    navigate,\n    children\n}) => {\n    const { dispatch } = useAuth();\n\n    const callbackDomain =\n        typeof window !== \"undefined\"\n            ? `${window.location.protocol}//${window.location.host}`\n            : \"http://localhost:8000\";\n\n    React.useEffect(() => {\n        // instantiate auth provider on page load\n        const authInstance = new authProvider({\n            dispatch,\n            ...authProvider.addDefaultParams(\n                params as ProviderOptions,\n                callbackDomain\n            )\n        });\n\n        // set config in XState\n        dispatch(\"SET_CONFIG\", {\n            authProvider: authInstance,\n            navigate,\n            callbackDomain\n        });\n\n        if (authInstance.checkSessionOnLoad) {\n            dispatch(\"CHECK_SESSION\");\n        }\n    }, [dispatch, authProvider, params, navigate]);\n\n    return <>{children}</>;\n};\n","import React, { useEffect } from \"react\";\nimport { AuthOptions as Auth0Options } from \"auth0-js\";\n\nimport { AuthProviderInterface } from \"./types\";\nimport { useAuth } from \"./useAuth\";\nimport { Auth0 } from \"./providers\";\n\nexport const AuthProvider: AuthProviderInterface = ({\n    children,\n    navigate,\n    auth0_audience_domain,\n    auth0_domain,\n    auth0_client_id,\n    auth0_params = {},\n    customPropertyNamespace\n}) => {\n    const callbackDomain =\n        typeof window !== \"undefined\"\n            ? `${window.location.protocol}//${window.location.host}`\n            : \"http://localhost:8000\";\n\n    const audienceDomain = auth0_audience_domain || auth0_domain;\n\n    const params: Auth0Options = {\n        domain: auth0_domain,\n        clientID: auth0_client_id,\n        redirectUri: `${callbackDomain}/auth0_callback`,\n        audience: `https://${audienceDomain}/api/v2/`,\n        responseType: \"token id_token\",\n        scope: \"openid profile email\"\n    };\n\n    const { dispatch } = useAuth();\n\n    // Instantiate Auth0 client\n\n    useEffect(() => {\n        const auth0 = new Auth0({\n            dispatch,\n            customPropertyNamespace,\n            ...params,\n            ...auth0_params\n        });\n\n        dispatch(\"SET_CONFIG\", {\n            authProvider: auth0,\n            navigate\n        });\n\n        dispatch(\"CHECK_SESSION\");\n    }, [navigate, customPropertyNamespace]);\n\n    useEffect(() => {\n        console.warn(\n            \"Using the AuthProvider root component is deprecated. Migrate to AuthConfig or manual dispatching. Takes  5min.\"\n        );\n    }, []);\n\n    return <React.Fragment>{children}</React.Fragment>;\n};\n"],"names":["authMachine","Machine","id","initial","context","user","expiresAt","authResult","isAuthenticating","error","undefined","errorType","config","navigate","console","callbackDomain","states","unauthenticated","on","LOGIN","CHECK_SESSION","SET_CONFIG","actions","authenticating","ERROR","AUTHENTICATED","entry","exit","verifying","invoke","src","event","authProvider","checkSession","onDone","target","onError","authenticated","LOGOUT","choose","cond","type","startAuthenticating","assign","stopAuthenticating","saveUserToContext","data","addSeconds","Date","expiresIn","clearUserFromContext","saveToLocalStorage","localStorage","setItem","toISOString","JSON","stringify","clearLocalStorage","removeItem","saveErrorToContext","setConfig","authService","interpret","start","send","getItem","now","isAfter","parse","differenceInSeconds","hydrateFromLocalStorage","useAuth","useService","state","dispatch","handleAuthentication","useCallback","postLoginRoute","warn","window","handleLoginCallback","loggedIn","isAuthenticated","isAuthorized","roles","_roles","Array","isArray","userRoles","some","role","includes","userId","login","authorize","signup","logout","postLogoutRoute","Auth0","params","this","customPropertyNamespace","auth0","Auth0Client","WebAuth","addDefaultParams","redirectUri","audience","domain","responseType","scope","mode","screen_hint","returnTo","sub","metadata","replace","Promise","resolve","reject","_this2","parseHash","err","handleAuthResult","_this4","accessToken","idToken","fetchUser","e","Error","_this6","_this8","client","userInfo","netlifyIdentity","NetlifyIdentityWidget","init","_this","token","_user$token","expires_in","_user$token2","NetlifyIdentity","open","children","location","protocol","host","React","authInstance","checkSessionOnLoad","auth0_domain","auth0_params","clientID","auth0_client_id","auth0_audience_domain","useEffect","Fragment"],"mappings":"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"}