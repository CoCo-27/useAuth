{"version":3,"file":"auth0.esm.js","sources":["../src/providers/auth0.ts"],"sourcesContent":["import {\n    Auth0DecodedHash,\n    Auth0Error,\n    Auth0ParseHashError,\n    Auth0UserProfile,\n    AuthOptions as Auth0Options,\n    WebAuth\n} from \"auth0-js\";\nimport {\n    AuthOptions,\n    AuthProviderClass,\n    AuthUser,\n    ProviderOptions\n} from \"../types\";\n\n// Wrapper that provides a common interface for different providers\n// Modeled after Auth0 because that was first :)\nexport class Auth0 implements AuthProviderClass {\n    private auth0?: WebAuth;\n    private dispatch: (eventName: string, eventData?: any) => void;\n    private customPropertyNamespace?: string;\n\n    constructor(params: AuthOptions) {\n        this.dispatch = params.dispatch;\n        this.customPropertyNamespace = params.customPropertyNamespace;\n\n        import(\"auth0-js\").then(({ WebAuth }) => {\n            // @ts-ignore I think TS is wrong here :P\n            this.auth0 = new WebAuth({\n                ...(params as Auth0Options)\n            });\n        });\n    }\n\n    // Makes configuration easier by guessing default options\n    static addDefaultParams(params: ProviderOptions, callbackDomain: string) {\n        const vals = params as Auth0Options;\n\n        return {\n            redirectUri: `${callbackDomain}/auth0_callback`,\n            audience: `https://${vals.domain}/api/v2/`,\n            responseType: \"token id_token\",\n            scope: \"openid profile email\",\n            ...vals\n        };\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.auth0?.authorize();\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.auth0?.authorize({\n            mode: \"signUp\",\n            screen_hint: \"signup\"\n        });\n    }\n\n    // Logs user out on the underlying service\n    public logout(returnTo?: string) {\n        this.auth0?.logout({ returnTo });\n    }\n\n    // Returns the userId from Auth0 shape of data\n    public userId(user: Auth0UserProfile): string {\n        return user.sub;\n    }\n\n    // Returns user roles from Auth0 shape of data\n    public userRoles(user: AuthUser): string[] | null {\n        const metadata =\n            user[\n                // make this friendlier to use if you leave a trailing slash in config\n                `${this.customPropertyNamespace}/user_metadata`.replace(\n                    /\\/+user_metadata/,\n                    \"/user_metadata\"\n                )\n            ];\n\n        return metadata?.roles || null;\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            this.auth0?.parseHash(\n                async (\n                    err: Auth0ParseHashError | null,\n                    authResult: Auth0DecodedHash | null\n                ) => {\n                    if (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"authResult\"\n                        });\n                        resolve(false);\n                    }\n\n                    try {\n                        const loggedIn = await this.handleAuthResult(\n                            authResult\n                        );\n\n                        resolve(loggedIn);\n                    } catch (err) {\n                        this.dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"handleAuth\"\n                        });\n                        resolve(false);\n                    }\n                }\n            );\n        });\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: Auth0UserProfile;\n        authResult: Auth0DecodedHash;\n    }> {\n        return new Promise((resolve, reject) => {\n            this.auth0?.checkSession(\n                {},\n                async (err: any, authResult: Auth0DecodedHash) => {\n                    if (\n                        !err &&\n                        authResult &&\n                        authResult.accessToken &&\n                        authResult.idToken\n                    ) {\n                        // fetch user data\n                        try {\n                            const user = await this.fetchUser(authResult);\n\n                            resolve({\n                                user,\n                                authResult\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(err || new Error(\"Session invalid\"));\n                    }\n                }\n            );\n        });\n    }\n\n    // Parses auth result and dispatches the AUTHENTICATED event\n    private async handleAuthResult(authResult: Auth0DecodedHash | null) {\n        if (authResult && authResult.accessToken && authResult.idToken) {\n            const user = await this.fetchUser(authResult);\n\n            this.dispatch(\"AUTHENTICATED\", {\n                authResult,\n                user\n            });\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Fetches current user info\n    private async fetchUser(\n        authResult: Auth0DecodedHash | null\n    ): Promise<Auth0UserProfile> {\n        return new Promise((resolve, reject) => {\n            this.auth0?.client.userInfo(\n                authResult?.accessToken || \"\",\n                (err: Auth0Error | null, user: Auth0UserProfile) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(user);\n                    }\n                }\n            );\n        });\n    }\n}\n"],"names":["Auth0","params","this","dispatch","customPropertyNamespace","import","then","_this","auth0","WebAuth","addDefaultParams","callbackDomain","redirectUri","audience","domain","responseType","scope","authorize","signup","mode","screen_hint","logout","returnTo","userId","user","sub","userRoles","metadata","replace","roles","handleLoginCallback","Promise","resolve","reject","parseHash","err","authResult","_this3","error","errorType","handleAuthResult","loggedIn","checkSession","accessToken","idToken","_this5","fetchUser","e","Error","_this7","client","userInfo"],"mappings":"sSAiBaA,IAAAA,aAKT,WAAYC,cACRC,KAAKC,SAAWF,EAAOE,SACvBD,KAAKE,wBAA0BH,EAAOG,wBAEtCC,OAAO,YAAYC,KAAK,YAEpBC,EAAKC,MAAQ,IAAIC,IAFMA,cAGfR,MAZpBD,EAkBWU,iBAAP,SAAwBT,EAAyBU,GAG7C,UACIC,YAAgBD,oBAChBE,oBAJSZ,EAIiBa,kBAC1BC,aAAc,iBACdC,MAAO,wBANEf,+BAYVgB,UAAA,+BACET,UAAOS,eAITC,OAAA,+BACEV,UAAOS,UAAU,CAClBE,KAAM,SACNC,YAAa,cAKdC,OAAA,SAAOC,uBACLd,UAAOa,OAAO,CAAEC,SAAAA,OAIlBC,OAAA,SAAOC,GACV,OAAOA,EAAKC,OAITC,UAAA,SAAUF,GACb,IAAMG,EACFH,GAEOtB,KAAKE,0CAAwCwB,QAC5C,mBACA,mBAIZ,aAAOD,SAAAA,EAAUE,QAAS,QAIjBC,yCAEL5B,KADJ,uBAAO,IAAI6B,QAAQ,SAACC,EAASC,oBACpBzB,UAAO0B,mBAEJC,EACAC,OAEID,IACAE,EAAKlC,SAAS,QAAS,CACnBmC,MAAOH,EACPI,UAAW,eAEfP,GAAQ,8CAIeK,EAAKG,iBACxBJ,kBADEK,GAINT,EAAQS,eACHN,GACLE,EAAKlC,SAAS,QAAS,CACnBmC,MAAOH,EACPI,UAAW,eAEfP,GAAQ,mEAxBpB,wCAtEZ,sCAuGiBU,kCAKLxC,KADJ,uBAAO,IAAI6B,QAAQ,SAACC,EAASC,oBACpBzB,UAAOkC,aACR,YACOP,EAAUC,4BAERD,GACDC,GACAA,EAAWO,aACXP,EAAWQ,mDAIYC,EAAKC,UAAUV,kBAA5BZ,GAENQ,EAAQ,CACJR,KAAAA,EACAY,WAAAA,gBAECW,GACLd,EAAOc,mDAGXd,EAAOE,GAAO,IAAIa,MAAM,qFArBpC,wCA5GZ,sCAyIkBR,0BAAiBJ,aAEJlC,KADvB,OAAIkC,GAAcA,EAAWO,aAAeP,EAAWQ,wBAChCK,EAAKH,UAAUV,kBAA5BZ,GAON,OALAyB,EAAK9C,SAAS,gBAAiB,CAC3BiC,WAAAA,EACAZ,KAAAA,0BAKG,GApJnB,sCAyJkBsB,mBACVV,aAGIlC,KADJ,uBAAO,IAAI6B,QAAQ,SAACC,EAASC,oBACpBzB,UAAO0C,OAAOC,gBACff,SAAAA,EAAYO,cAAe,GAC3B,SAACR,EAAwBX,GACjBW,EACAF,EAAOE,GAEPH,EAAQR,QAnKhC"}