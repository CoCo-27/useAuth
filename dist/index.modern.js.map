{"version":3,"file":"index.modern.js","sources":["../src/authReducer.ts","../src/useAuth.ts","../src/providers/auth0.ts","../src/AuthProvider.tsx"],"sourcesContent":["import { addSeconds, differenceInSeconds, isAfter } from \"date-fns\";\nimport { Machine, assign, interpret } from \"xstate\";\nimport { choose } from \"xstate/lib/actions\";\nimport { AuthState } from \"./types\";\n\nexport const authMachine = Machine<AuthState>(\n    {\n        id: \"useAuth\",\n        initial: \"unauthenticated\",\n        context: {\n            user: {},\n            expiresAt: null,\n            authResult: null,\n            isAuthenticating: false,\n            error: undefined,\n            errorType: undefined,\n            config: {\n                navigate: () =>\n                    console.error(\n                        \"Please specify a navigation method that works with your router\"\n                    ),\n                callbackDomain: \"http://localhost:8000\",\n                customPropertyNamespace: \"http://localhost:8000\"\n            }\n        },\n        states: {\n            unauthenticated: {\n                on: {\n                    LOGIN: \"authenticating\",\n                    CHECK_SESSION: \"verifying\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                }\n            },\n            authenticating: {\n                on: {\n                    ERROR: \"error\",\n                    AUTHENTICATED: \"authenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            verifying: {\n                invoke: {\n                    id: \"checkSession\",\n                    src: (context, event) =>\n                        context.config.authProvider.checkSession(),\n                    onDone: {\n                        target: \"authenticated\"\n                    },\n                    onError: {\n                        target: \"error\"\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            authenticated: {\n                on: {\n                    LOGOUT: \"unauthenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    },\n                    CHECK_SESSION: \"verifying\"\n                },\n                entry: [\"saveUserToContext\", \"saveToLocalStorage\"],\n                exit: choose([\n                    {\n                        cond: (context, event) =>\n                            event.type !== \"CHECK_SESSION\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                ])\n            },\n            error: {\n                entry: [\n                    \"saveErrorToContext\",\n                    \"clearUserFromContext\",\n                    \"clearLocalStorage\"\n                ]\n            }\n        }\n    },\n    {\n        actions: {\n            startAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: true\n                };\n            }),\n            stopAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: false\n                };\n            }),\n            saveUserToContext: assign((context, event) => {\n                const { authResult, user } = event.data ? event.data : event;\n                const expiresAt = addSeconds(new Date(), authResult.expiresIn);\n\n                return {\n                    user,\n                    authResult,\n                    expiresAt\n                };\n            }),\n            clearUserFromContext: assign(context => {\n                return {\n                    user: {},\n                    expiresAt: null,\n                    authResult: null\n                };\n            }),\n            saveToLocalStorage: (context, event) => {\n                const { expiresAt, user } = context;\n\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(\n                        \"useAuth:expires_at\",\n                        expiresAt ? expiresAt.toISOString() : \"0\"\n                    );\n                    localStorage.setItem(\"useAuth:user\", JSON.stringify(user));\n                }\n            },\n            clearLocalStorage: () => {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.removeItem(\"useAuth:expires_at\");\n                    localStorage.removeItem(\"useAuth:user\");\n                }\n            },\n            saveErrorToContext: assign((context, event) => {\n                return {\n                    errorType: event.errorType,\n                    error: event.error\n                };\n            }),\n            setConfig: assign((context, event) => {\n                return {\n                    config: {\n                        ...context.config,\n                        ...event\n                    }\n                };\n            })\n        }\n    }\n);\n\n// check localstorage and login as soon as this file loads\nfunction hydrateFromLocalStorage(send: any) {\n    if (typeof localStorage !== \"undefined\") {\n        const expiresAt = new Date(\n                localStorage.getItem(\"useAuth:expires_at\") || \"0\"\n            ),\n            now = new Date();\n\n        if (isAfter(expiresAt, now)) {\n            const user = JSON.parse(\n                localStorage.getItem(\"useAuth:user\") || \"{}\"\n            );\n            send(\"LOGIN\");\n            send(\"AUTHENTICATED\", {\n                user,\n                authResult: {\n                    expiresIn: differenceInSeconds(expiresAt, now)\n                }\n            });\n        }\n    }\n}\n\nexport const authService = interpret(authMachine);\nauthService.start();\n\nhydrateFromLocalStorage(authService.send);\n","import { useCallback } from \"react\";\n\nimport { useAuthInterface } from \"./types\";\nimport { useService } from \"@xstate/react\";\nimport { authService } from \"./authReducer\";\nimport { isAfter } from \"date-fns\";\n\n/**\n * The main API for useAuth\n *\n * @return {boolean} isAuthenticated is current user authenticated\n * @return {boolean} isAuthenticating currently running authentication\n * @return {function} isAuthorized check if current user is authenticated and matches list of roles\n * @return {object} user current user\n * @return {string} userId current user's identifier\n * @return {object} authResult raw authentication result object from auth provider\n * @return {function} login start the login process\n * @return {function} signup same as login, passes { mode: \"signUp\", screen_hint: \"signup\" } to Auth0\n * @return {function} logout start the logout process\n * @return {function} handleAuthentication function to call on your callback page\n */\nexport const useAuth: useAuthInterface = () => {\n    const [state, dispatch] = useService(authService);\n\n    const {\n        authProvider,\n        navigate,\n        callbackDomain,\n        customPropertyNamespace\n    } = state.context.config;\n\n    const login = () => {\n        authProvider?.authorize();\n    };\n\n    const signup = () => {\n        authProvider?.authorize({ mode: \"signUp\", screen_hint: \"signup\" });\n    };\n\n    const logout = () => {\n        authProvider?.logout({\n            returnTo: callbackDomain\n        });\n        dispatch(\"LOGOUT\");\n\n        // Return to the homepage after logout.\n        navigate(\"/\");\n    };\n\n    const handleAuthentication = useCallback(\n        async ({ postLoginRoute = \"/\" } = {}) => {\n            if (!authProvider || !navigate || !callbackDomain) {\n                console.warn(\"authProvider not configured yet\");\n                return;\n            }\n\n            if (typeof window !== \"undefined\") {\n                dispatch(\"LOGIN\");\n\n                const loggedIn = await authProvider.handleLoginCallback();\n\n                if (loggedIn) {\n                    navigate(postLoginRoute);\n                }\n            }\n        },\n        [authProvider, navigate, callbackDomain]\n    );\n\n    const isAuthenticated = () => {\n        return !!(\n            state.context.expiresAt &&\n            isAfter(state.context.expiresAt, new Date())\n        );\n    };\n\n    // TODO: this is potentially too tied to Auth0\n    const isAuthorized = (roles: string | string[]) => {\n        const _roles = Array.isArray(roles) ? roles : [roles];\n        const metadata =\n            state.context.user[\n                // make this friendlier to use if you leave a trailing slash in config\n                `${customPropertyNamespace}/user_metadata`.replace(\n                    /\\/+user_metadata/,\n                    \"/user_metadata\"\n                )\n            ];\n\n        if (!isAuthenticated() || !metadata) {\n            return false;\n        } else {\n            return _roles.some(role => metadata.roles.includes(role));\n        }\n    };\n\n    return {\n        isAuthenticating: state.context.isAuthenticating,\n        isAuthenticated,\n        isAuthorized,\n        user: state.context.user,\n        userId: state.context.user ? state.context.user.sub : null,\n        authResult: state.context.authResult,\n        login,\n        signup,\n        logout,\n        handleAuthentication,\n        dispatch\n    };\n};\n","import Auth0Client, {\n    Auth0DecodedHash,\n    Auth0Error,\n    Auth0ParseHashError,\n    Auth0UserProfile,\n    AuthOptions\n} from \"auth0-js\";\nimport { AuthProviderClass } from \"../types\";\n\n// Wrapper that provides a common interface for different providers\n// Modeled after Auth0 because that was first :)\nexport class Auth0 implements AuthProviderClass {\n    private auth0: Auth0Client.WebAuth | null;\n\n    constructor(params: AuthOptions) {\n        this.auth0 = new Auth0Client.WebAuth({\n            ...params\n        });\n    }\n\n    // Opens login dialog\n    public authorize() {\n        this.auth0?.authorize();\n    }\n\n    // Opens signup dialog\n    public signup() {\n        this.auth0?.authorize({\n            mode: \"signUp\",\n            screen_hint: \"signup\"\n        });\n    }\n\n    // Logs user out on the underlying service\n    public logout(args: { returnTo?: string }) {\n        this.auth0?.logout(args);\n    }\n\n    // Handles login after redirect back from service\n    public async handleLoginCallback(args: {\n        dispatch: any;\n    }): Promise<boolean> {\n        const { dispatch } = args;\n\n        return new Promise((resolve, reject) => {\n            this.auth0?.parseHash(\n                async (\n                    err: Auth0ParseHashError | null,\n                    authResult: Auth0DecodedHash | null\n                ) => {\n                    if (err) {\n                        dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"authResult\"\n                        });\n                        resolve(false);\n                    }\n\n                    try {\n                        const loggedIn = await this.handleAuthResult({\n                            authResult,\n                            dispatch\n                        });\n\n                        resolve(loggedIn);\n                    } catch (err) {\n                        dispatch(\"ERROR\", {\n                            error: err,\n                            errorType: \"handleAuth\"\n                        });\n                        resolve(false);\n                    }\n                }\n            );\n        });\n    }\n\n    // verifies session is still valid\n    // returns fresh user info\n    public async checkSession(): Promise<{\n        user: Auth0UserProfile;\n        authResult: Auth0DecodedHash;\n    }> {\n        return new Promise((resolve, reject) => {\n            this.auth0?.checkSession(\n                {},\n                async (err: any, authResult: Auth0DecodedHash) => {\n                    if (\n                        !err &&\n                        authResult &&\n                        authResult.accessToken &&\n                        authResult.idToken\n                    ) {\n                        // fetch user data\n                        try {\n                            const user = await this.fetchUser({\n                                authResult\n                            });\n\n                            resolve({\n                                user,\n                                authResult\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(err || new Error(\"Session invalid\"));\n                    }\n                }\n            );\n        });\n    }\n\n    // Parses auth result and dispatches the AUTHENTICATED event\n    private async handleAuthResult(args: {\n        dispatch: any;\n        authResult: Auth0DecodedHash | null;\n    }) {\n        const { dispatch, authResult } = args;\n\n        if (authResult && authResult.accessToken && authResult.idToken) {\n            const user = await this.fetchUser({\n                authResult\n            });\n\n            dispatch(\"AUTHENTICATED\", {\n                authResult,\n                user\n            });\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    // Fetches current user info\n    private async fetchUser(args: {\n        authResult: Auth0DecodedHash | null;\n    }): Promise<Auth0UserProfile> {\n        return new Promise((resolve, reject) => {\n            this.auth0?.client.userInfo(\n                args.authResult?.accessToken || \"\",\n                (err: Auth0Error | null, user: Auth0UserProfile) => {\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(user);\n                    }\n                }\n            );\n        });\n    }\n}\n","import React, { useEffect } from \"react\";\nimport { AuthOptions } from \"auth0-js\";\n\nimport { AuthProviderInterface } from \"./types\";\nimport { useAuth } from \"./useAuth\";\nimport { Auth0 } from \"./providers/auth0\";\n\nexport const AuthProvider: AuthProviderInterface = ({\n    children,\n    navigate,\n    auth0_audience_domain,\n    auth0_domain,\n    auth0_client_id,\n    auth0_params = {},\n    customPropertyNamespace\n}) => {\n    const callbackDomain =\n        typeof window !== \"undefined\"\n            ? `${window.location.protocol}//${window.location.host}`\n            : \"http://localhost:8000\";\n\n    const audienceDomain = auth0_audience_domain || auth0_domain;\n\n    const params: AuthOptions = {\n        domain: auth0_domain,\n        clientID: auth0_client_id,\n        redirectUri: `${callbackDomain}/auth0_callback`,\n        audience: `https://${audienceDomain}/api/v2/`,\n        responseType: \"token id_token\",\n        scope: \"openid profile email\"\n    };\n\n    const { dispatch } = useAuth();\n\n    // Instantiate Auth0 client\n\n    useEffect(() => {\n        const auth0 = new Auth0({ ...params, ...auth0_params });\n\n        dispatch(\"SET_CONFIG\", {\n            authProvider: auth0,\n            navigate,\n            customPropertyNamespace,\n            callbackDomain\n        });\n\n        dispatch(\"CHECK_SESSION\");\n    }, [navigate, customPropertyNamespace, callbackDomain]);\n\n    return <React.Fragment>{children}</React.Fragment>;\n};\n"],"names":["authService","interpret","Machine","id","initial","context","user","expiresAt","authResult","isAuthenticating","error","undefined","errorType","config","navigate","console","callbackDomain","customPropertyNamespace","states","unauthenticated","on","LOGIN","CHECK_SESSION","SET_CONFIG","actions","authenticating","ERROR","AUTHENTICATED","entry","exit","verifying","invoke","src","event","authProvider","checkSession","onDone","target","onError","authenticated","LOGOUT","choose","cond","type","startAuthenticating","assign","stopAuthenticating","saveUserToContext","data","addSeconds","Date","expiresIn","clearUserFromContext","saveToLocalStorage","localStorage","setItem","toISOString","JSON","stringify","clearLocalStorage","removeItem","saveErrorToContext","setConfig","start","send","getItem","now","isAfter","parse","differenceInSeconds","hydrateFromLocalStorage","useAuth","state","dispatch","useService","handleAuthentication","useCallback","async","postLoginRoute","window","handleLoginCallback","warn","isAuthenticated","isAuthorized","roles","_roles","Array","isArray","metadata","replace","some","role","includes","userId","sub","login","authorize","signup","mode","screen_hint","logout","returnTo","Auth0","constructor","params","this","auth0","Auth0Client","WebAuth","args","[object Object]","Promise","resolve","reject","parseHash","err","loggedIn","_this","handleAuthResult","accessToken","idToken","_this2","fetchUser","e","Error","client","userInfo","AuthProvider","children","auth0_audience_domain","auth0_domain","auth0_client_id","auth0_params","location","protocol","host","domain","clientID","redirectUri","audience","responseType","scope","useEffect","React","Fragment"],"mappings":"kgBA8KaA,EAAcC,EAzKAC,EACvB,CACIC,GAAI,UACJC,QAAS,kBACTC,QAAS,CACLC,KAAM,GACNC,UAAW,KACXC,WAAY,KACZC,kBAAkB,EAClBC,WAAOC,EACPC,eAAWD,EACXE,OAAQ,CACJC,SAAU,IACNC,QAAQL,MACJ,kEAERM,eAAgB,wBAChBC,wBAAyB,0BAGjCC,OAAQ,CACJC,gBAAiB,CACbC,GAAI,CACAC,MAAO,iBACPC,cAAe,YACfC,WAAY,CACRC,QAAS,CAAC,gBAItBC,eAAgB,CACZL,GAAI,CACAM,MAAO,QACPC,cAAe,gBACfJ,WAAY,CACRC,QAAS,CAAC,eAGlBI,MAAO,CAAC,uBACRC,KAAM,CAAC,uBAEXC,UAAW,CACPC,OAAQ,CACJ5B,GAAI,eACJ6B,IAAK,CAAC3B,EAAS4B,IACX5B,EAAQQ,OAAOqB,aAAaC,eAChCC,OAAQ,CACJC,OAAQ,iBAEZC,QAAS,CACLD,OAAQ,UAGhBT,MAAO,CAAC,uBACRC,KAAM,CAAC,uBAEXU,cAAe,CACXnB,GAAI,CACAoB,OAAQ,kBACRjB,WAAY,CACRC,QAAS,CAAC,cAEdF,cAAe,aAEnBM,MAAO,CAAC,oBAAqB,sBAC7BC,KAAMY,EAAO,CACT,CACIC,KAAM,CAACrC,EAAS4B,IACG,kBAAfA,EAAMU,KACVnB,QAAS,CAAC,uBAAwB,yBAI9Cd,MAAO,CACHkB,MAAO,CACH,qBACA,uBACA,wBAKhB,CACIJ,QAAS,CACLoB,oBAAqBC,EAAOxC,IACjB,CACHI,kBAAkB,KAG1BqC,mBAAoBD,EAAOxC,IAChB,CACHI,kBAAkB,KAG1BsC,kBAAmBF,EAAO,CAACxC,EAAS4B,KAChC,MAAMzB,WAAEA,EAAFF,KAAcA,GAAS2B,EAAMe,KAAOf,EAAMe,KAAOf,EAGvD,MAAO,CACH3B,KAAAA,EACAE,WAAAA,EACAD,UALc0C,EAAW,IAAIC,KAAQ1C,EAAW2C,cAQxDC,qBAAsBP,EAAOxC,IAClB,CACHC,KAAM,GACNC,UAAW,KACXC,WAAY,QAGpB6C,mBAAoB,CAAChD,EAAS4B,KAC1B,MAAM1B,UAAEA,EAAFD,KAAaA,GAASD,EAEA,oBAAjBiD,eACPA,aAAaC,QACT,qBACAhD,EAAYA,EAAUiD,cAAgB,KAE1CF,aAAaC,QAAQ,eAAgBE,KAAKC,UAAUpD,MAG5DqD,kBAAmB,KACa,oBAAjBL,eACPA,aAAaM,WAAW,sBACxBN,aAAaM,WAAW,kBAGhCC,mBAAoBhB,EAAO,CAACxC,EAAS4B,KAC1B,CACHrB,UAAWqB,EAAMrB,UACjBF,MAAOuB,EAAMvB,SAGrBoD,UAAWjB,EAAO,CAACxC,EAAS4B,KACjB,CACHpB,YACOR,EAAQQ,OACRoB,UAgC3BjC,EAAY+D,QAvBZ,SAAiCC,GAC7B,GAA4B,oBAAjBV,aAA8B,CACrC,MAAM/C,EAAY,IAAI2C,KACdI,aAAaW,QAAQ,uBAAyB,KAElDC,EAAM,IAAIhB,KAEd,GAAIiB,EAAQ5D,EAAW2D,GAAM,CACzB,MAAM5D,EAAOmD,KAAKW,MACdd,aAAaW,QAAQ,iBAAmB,MAE5CD,EAAK,SACLA,EAAK,gBAAiB,CAClB1D,KAAAA,EACAE,WAAY,CACR2C,UAAWkB,EAAoB9D,EAAW2D,QAU9DI,CAAwBtE,EAAYgE,MC5JvBO,MAAAA,EAA4B,KACrC,MAAOC,EAAOC,GAAYC,EAAW1E,IAE/BkC,aACFA,EADEpB,SAEFA,EAFEE,eAGFA,EAHEC,wBAIFA,GACAuD,EAAMnE,QAAQQ,OAoBZ8D,EAAuBC,EACzBC,OAASC,eAAAA,EAAiB,KAAQ,MACzB5C,GAAiBpB,GAAaE,EAKb,oBAAX+D,SACPN,EAAS,eAEcvC,EAAa8C,uBAGhClE,EAASgE,IAVb/D,QAAQkE,KAAK,oCAcrB,CAAC/C,EAAcpB,EAAUE,IAGvBkE,EAAkB,OAEhBV,EAAMnE,QAAQE,YACd4D,EAAQK,EAAMnE,QAAQE,UAAW,IAAI2C,OAuB7C,MAAO,CACHzC,iBAAkB+D,EAAMnE,QAAQI,iBAChCyE,gBAAAA,EACAC,aArBkBC,IAClB,MAAMC,EAASC,MAAMC,QAAQH,GAASA,EAAQ,CAACA,GACzCI,EACFhB,EAAMnE,QAAQC,MAEPW,oBAAwCwE,QACvC,mBACA,mBAIZ,SAAKP,MAAsBM,IAGhBH,EAAOK,KAAKC,GAAQH,EAASJ,MAAMQ,SAASD,KAQvDrF,KAAMkE,EAAMnE,QAAQC,KACpBuF,OAAQrB,EAAMnE,QAAQC,KAAOkE,EAAMnE,QAAQC,KAAKwF,IAAM,KACtDtF,WAAYgE,EAAMnE,QAAQG,WAC1BuF,MAvEU,WACV7D,GAAAA,EAAc8D,aAuEdC,OApEW,WACX/D,GAAAA,EAAc8D,UAAU,CAAEE,KAAM,SAAUC,YAAa,YAoEvDC,OAjEW,WACXlE,GAAAA,EAAckE,OAAO,CACjBC,SAAUrF,IAEdyD,EAAS,UAGT3D,EAAS,MA2DT6D,qBAAAA,EACAF,SAAAA,UC/FK6B,EAGTC,YAAYC,GACRC,KAAKC,MAAQ,IAAIC,EAAYC,aACtBJ,IAKJR,gCACEU,UAAOV,YAITC,6BACES,UAAOV,UAAU,CAClBE,KAAM,SACNC,YAAa,WAKdC,OAAOS,uBACLH,UAAON,OAAOS,GAIhBC,0BAA0BD,cAG7B,MAAMpC,SAAEA,GAAaoC,EAErB,WAAWE,QAAQ,CAACC,EAASC,yBACpBP,UAAOQ,UACRrC,eACIsC,EACA3G,GAEI2G,IACA1C,EAAS,QAAS,CACd/D,MAAOyG,EACPvG,UAAW,eAEfoG,GAAQ,IAGZ,IACI,MAAMI,QAAiBC,EAAKC,iBAAiB,CACzC9G,WAAAA,EACAiE,SAAAA,IAGJuC,EAAQI,GACV,MAAOD,GACL1C,EAAS,QAAS,CACd/D,MAAOyG,EACPvG,UAAW,eAEfoG,GAAQ,QASrBF,gCAIH,WAAWC,QAAQ,CAACC,EAASC,yBACpBP,UAAOvE,aACR,GACA0C,eAAOsC,EAAU3G,GACb,IACK2G,GACD3G,GACAA,EAAW+G,aACX/G,EAAWgH,QAGX,IACI,MAAMlH,QAAamH,EAAKC,UAAU,CAC9BlH,WAAAA,IAGJwG,EAAQ,CACJ1G,KAAAA,EACAE,WAAAA,IAEN,MAAOmH,GACLV,EAAOU,QAGXV,EAAOE,GAAO,IAAIS,MAAM,wBAQpCd,uBAAuBD,GAI3B,MAAMpC,SAAEA,EAAFjE,WAAYA,GAAeqG,EAEjC,SAAIrG,GAAcA,EAAW+G,aAAe/G,EAAWgH,WAKnD/C,EAAS,gBAAiB,CACtBjE,WAAAA,EACAF,gBANoBoH,UAAU,CAC9BlH,WAAAA,UAeJsG,gBAAgBD,GAGpB,WAAWE,QAAQ,CAACC,EAASC,2BACpBP,UAAOmB,OAAOC,mBACfjB,EAAKrG,qBAAY+G,cAAe,GAChC,CAACJ,EAAwB7G,KACjB6G,EACAF,EAAOE,GAEPH,EAAQ1G,QC7InByH,MAAAA,EAAsC,EAC/CC,SAAAA,EACAlH,SAAAA,EACAmH,sBAAAA,EACAC,aAAAA,EACAC,gBAAAA,EACAC,aAAAA,EAAe,GACfnH,wBAAAA,MAEA,MAAMD,EACgB,oBAAX+D,UACEA,OAAOsD,SAASC,aAAavD,OAAOsD,SAASE,OAChD,wBAIJ/B,EAAsB,CACxBgC,OAAQN,EACRO,SAAUN,EACVO,YAAgB1H,oBAChB2H,oBANmBV,GAAyBC,YAO5CU,aAAc,iBACdC,MAAO,yBAGLpE,SAAEA,GAAaF,IAiBrB,OAbAuE,EAAU,KACN,MAAMpC,EAAQ,IAAIJ,OAAWE,EAAW4B,IAExC3D,EAAS,aAAc,CACnBvC,aAAcwE,EACd5F,SAAAA,EACAG,wBAAAA,EACAD,eAAAA,IAGJyD,EAAS,kBACV,CAAC3D,EAAUG,EAAyBD,IAEhC+H,gBAACA,EAAMC,cAAUhB"}