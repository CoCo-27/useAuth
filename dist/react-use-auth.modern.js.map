{"version":3,"file":"react-use-auth.modern.js","sources":["../src/AuthProvider.tsx","../src/authReducer.ts","../src/useAuth.ts","../src/AuthConfig.tsx"],"sourcesContent":["import React, { useEffect } from \"react\";\nimport { AuthOptions as Auth0Options } from \"auth0-js\";\n\nimport { AuthProviderInterface } from \"./types\";\nimport { useAuth } from \"./useAuth\";\n// import { Auth0 } from \"./providers/auth0\";\n\nexport const AuthProvider: AuthProviderInterface = ({\n    children,\n    navigate,\n    auth0_audience_domain,\n    auth0_domain,\n    auth0_client_id,\n    auth0_params = {},\n    customPropertyNamespace\n}) => {\n    useEffect(() => {\n        console.error(\n            \"The AuthProvider root component no longer works. Please take 5min to migrate to AuthConfig. ðŸ‘‰ https://useauth.dev/docs/upgrading\"\n        );\n    }, []);\n\n    return <React.Fragment>{children}</React.Fragment>;\n};\n","import { addSeconds, differenceInSeconds, isAfter } from \"date-fns\";\nimport { Machine, assign, interpret } from \"xstate\";\nimport { choose } from \"xstate/lib/actions\";\nimport { AuthState } from \"./types\";\n\nexport const authMachine = Machine<AuthState>(\n    {\n        id: \"useAuth\",\n        initial: \"unauthenticated\",\n        context: {\n            user: {},\n            expiresAt: null,\n            authResult: null,\n            isAuthenticating: false,\n            error: undefined,\n            errorType: undefined,\n            config: {\n                navigate: () =>\n                    console.error(\n                        \"Please specify a navigation method that works with your router\"\n                    ),\n                // TODO: detect default\n                callbackDomain: \"http://localhost:8000\"\n            }\n        },\n        states: {\n            unauthenticated: {\n                on: {\n                    LOGIN: \"authenticating\",\n                    CHECK_SESSION: \"verifying\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                }\n            },\n            authenticating: {\n                on: {\n                    ERROR: \"error\",\n                    AUTHENTICATED: \"authenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            verifying: {\n                invoke: {\n                    id: \"checkSession\",\n                    src: (context, event) =>\n                        context.config.authProvider!.checkSession(),\n                    onDone: {\n                        target: \"authenticated\"\n                    },\n                    onError: {\n                        target: \"unauthenticated\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                },\n                entry: [\"startAuthenticating\"],\n                exit: [\"stopAuthenticating\"]\n            },\n            authenticated: {\n                on: {\n                    LOGOUT: \"unauthenticated\",\n                    SET_CONFIG: {\n                        actions: [\"setConfig\"]\n                    },\n                    CHECK_SESSION: \"verifying\"\n                },\n                entry: [\"saveUserToContext\", \"saveToLocalStorage\"],\n                exit: choose([\n                    {\n                        cond: (context, event) =>\n                            event.type !== \"CHECK_SESSION\",\n                        actions: [\"clearUserFromContext\", \"clearLocalStorage\"]\n                    }\n                ])\n            },\n            error: {\n                entry: [\n                    \"saveErrorToContext\",\n                    \"clearUserFromContext\",\n                    \"clearLocalStorage\"\n                ]\n            }\n        }\n    },\n    {\n        actions: {\n            startAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: true\n                };\n            }),\n            stopAuthenticating: assign(context => {\n                return {\n                    isAuthenticating: false\n                };\n            }),\n            saveUserToContext: assign((context, event) => {\n                const { authResult, user } = event.data ? event.data : event;\n                const expiresAt = addSeconds(new Date(), authResult.expiresIn);\n\n                return {\n                    user,\n                    authResult,\n                    expiresAt\n                };\n            }),\n            clearUserFromContext: assign(context => {\n                return {\n                    user: {},\n                    expiresAt: null,\n                    authResult: null\n                };\n            }),\n            saveToLocalStorage: (context, event) => {\n                const { expiresAt, user } = context;\n\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.setItem(\n                        \"useAuth:expires_at\",\n                        expiresAt ? expiresAt.toISOString() : \"0\"\n                    );\n                    localStorage.setItem(\"useAuth:user\", JSON.stringify(user));\n                }\n            },\n            clearLocalStorage: () => {\n                if (typeof localStorage !== \"undefined\") {\n                    localStorage.removeItem(\"useAuth:expires_at\");\n                    localStorage.removeItem(\"useAuth:user\");\n                }\n            },\n            saveErrorToContext: assign((context, event) => {\n                return {\n                    errorType: event.errorType,\n                    error: event.error\n                };\n            }),\n            setConfig: assign((context, event) => {\n                return {\n                    config: {\n                        ...context.config,\n                        ...event\n                    }\n                };\n            })\n        }\n    }\n);\n\n// check localstorage and login as soon as this file loads\nfunction hydrateFromLocalStorage(send: any) {\n    if (typeof localStorage !== \"undefined\") {\n        const expiresAt = new Date(\n                localStorage.getItem(\"useAuth:expires_at\") || \"0\"\n            ),\n            now = new Date();\n\n        if (isAfter(expiresAt, now)) {\n            const user = JSON.parse(\n                localStorage.getItem(\"useAuth:user\") || \"{}\"\n            );\n            send(\"LOGIN\");\n            send(\"AUTHENTICATED\", {\n                user,\n                authResult: {\n                    expiresIn: differenceInSeconds(expiresAt, now)\n                }\n            });\n        }\n    }\n}\n\nexport const authService = interpret(authMachine);\nauthService.start();\n\nhydrateFromLocalStorage(authService.send);\n","import { useCallback } from \"react\";\n\nimport { useAuthInterface } from \"./types\";\nimport { useService } from \"@xstate/react\";\nimport { authService } from \"./authReducer\";\nimport { isAfter } from \"date-fns\";\n\n/**\n * The main API for useAuth\n *\n * @return {boolean} isAuthenticated is current user authenticated\n * @return {boolean} isAuthenticating currently running authentication\n * @return {function} isAuthorized check if current user is authenticated and matches list of roles\n * @return {object} user current user\n * @return {string} userId current user's identifier\n * @return {object} authResult raw authentication result object from auth provider\n * @return {function} login start the login process\n * @return {function} signup same as login, passes { mode: \"signUp\", screen_hint: \"signup\" } to Auth0\n * @return {function} logout start the logout process\n * @return {function} handleAuthentication function to call on your callback page\n */\nexport const useAuth: useAuthInterface = () => {\n    const [state, dispatch] = useService(authService);\n\n    const { authProvider, navigate, callbackDomain } = state.context.config;\n\n    const login = () => {\n        authProvider?.authorize();\n    };\n\n    const signup = () => {\n        authProvider?.signup();\n    };\n\n    const logout = (postLogoutRoute?: string) => {\n        // React sends a click event by default, we don't care\n        if (typeof postLogoutRoute === \"string\") {\n            authProvider?.logout(`${callbackDomain}${postLogoutRoute}`);\n        } else {\n            authProvider?.logout();\n        }\n\n        dispatch(\"LOGOUT\");\n\n        // Return to the homepage after logout.\n        navigate(typeof postLogoutRoute === \"string\" ? postLogoutRoute : \"/\");\n    };\n\n    const handleAuthentication = useCallback(\n        async ({ postLoginRoute = \"/\" } = {}) => {\n            if (!authProvider || !navigate) {\n                console.warn(\"authProvider not configured yet\");\n                return;\n            }\n\n            if (typeof window !== \"undefined\") {\n                dispatch(\"LOGIN\");\n\n                const loggedIn = await authProvider.handleLoginCallback(\n                    dispatch\n                );\n\n                if (loggedIn) {\n                    navigate(postLoginRoute);\n                }\n            }\n        },\n        [authProvider, navigate]\n    );\n\n    const isAuthenticated = () => {\n        return !!(\n            state.context.expiresAt &&\n            isAfter(state.context.expiresAt, new Date())\n        );\n    };\n\n    const isAuthorized = (roles: string | string[]) => {\n        const _roles = Array.isArray(roles) ? roles : [roles];\n        const userRoles = authProvider?.userRoles(state.context.user);\n\n        if (!isAuthenticated() || !userRoles) {\n            return false;\n        } else {\n            return _roles.some(role => userRoles.includes(role));\n        }\n    };\n\n    return {\n        isAuthenticating: state.context.isAuthenticating,\n        isAuthenticated,\n        isAuthorized,\n        user: state.context.user,\n        userId: authProvider?.userId(state.context.user),\n        authResult: state.context.authResult,\n        login,\n        signup,\n        logout,\n        handleAuthentication,\n        dispatch\n    };\n};\n","import * as React from \"react\";\nimport { AuthConfigInterface, ProviderOptions } from \"./types\";\nimport { useAuth } from \"./useAuth\";\n\nexport const AuthConfig: AuthConfigInterface = ({\n    authProvider,\n    params,\n    navigate,\n    children\n}) => {\n    const { dispatch } = useAuth();\n\n    const callbackDomain =\n        typeof window !== \"undefined\"\n            ? `${window.location.protocol}//${window.location.host}`\n            : \"http://localhost:8000\";\n\n    React.useEffect(() => {\n        // instantiate auth provider on page load\n        const authInstance = new authProvider({\n            dispatch,\n            ...authProvider.addDefaultParams(\n                params as ProviderOptions,\n                callbackDomain\n            )\n        });\n\n        // set config in XState\n        dispatch(\"SET_CONFIG\", {\n            authProvider: authInstance,\n            navigate,\n            callbackDomain\n        });\n\n        dispatch(\"CHECK_SESSION\");\n    }, [dispatch, authProvider, params, navigate]);\n\n    return <>{children}</>;\n};\n"],"names":["AuthProvider","children","auth0_params","useEffect","console","error","React","Fragment","authService","interpret","Machine","id","initial","context","user","expiresAt","authResult","isAuthenticating","undefined","errorType","config","navigate","callbackDomain","states","unauthenticated","on","LOGIN","CHECK_SESSION","SET_CONFIG","actions","authenticating","ERROR","AUTHENTICATED","entry","exit","verifying","invoke","src","event","authProvider","checkSession","onDone","target","onError","authenticated","LOGOUT","choose","cond","type","startAuthenticating","assign","stopAuthenticating","saveUserToContext","data","addSeconds","Date","expiresIn","clearUserFromContext","saveToLocalStorage","localStorage","setItem","toISOString","JSON","stringify","clearLocalStorage","removeItem","saveErrorToContext","setConfig","start","send","getItem","now","isAfter","parse","differenceInSeconds","hydrateFromLocalStorage","useAuth","state","dispatch","useService","handleAuthentication","useCallback","async","postLoginRoute","window","handleLoginCallback","warn","isAuthenticated","isAuthorized","roles","_roles","Array","isArray","userRoles","some","role","includes","userId","login","authorize","signup","logout","postLogoutRoute","AuthConfig","params","location","protocol","host","authInstance","addDefaultParams"],"mappings":"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"}